// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: queries.sql

package database

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addUserFavoriteJobListing = `-- name: AddUserFavoriteJobListing :exec
INSERT INTO user_favorite_job_listing ("user", job_listing)
VALUES ($1, $2)
`

type AddUserFavoriteJobListingParams struct {
	User       int32
	JobListing int32
}

func (q *Queries) AddUserFavoriteJobListing(ctx context.Context, arg AddUserFavoriteJobListingParams) error {
	_, err := q.db.Exec(ctx, addUserFavoriteJobListing, arg.User, arg.JobListing)
	return err
}

const createJobApplication = `-- name: CreateJobApplication :one
INSERT INTO job_application ("user", job_listing, cover_letter, status, sent_date, relevant_skills)
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id, "user", job_listing, cover_letter, status, sent_date, relevant_skills
`

type CreateJobApplicationParams struct {
	User           int32
	JobListing     int32
	CoverLetter    pgtype.Text
	Status         string
	SentDate       pgtype.Date
	RelevantSkills []string
}

func (q *Queries) CreateJobApplication(ctx context.Context, arg CreateJobApplicationParams) (JobApplication, error) {
	row := q.db.QueryRow(ctx, createJobApplication,
		arg.User,
		arg.JobListing,
		arg.CoverLetter,
		arg.Status,
		arg.SentDate,
		arg.RelevantSkills,
	)
	var i JobApplication
	err := row.Scan(
		&i.ID,
		&i.User,
		&i.JobListing,
		&i.CoverLetter,
		&i.Status,
		&i.SentDate,
		&i.RelevantSkills,
	)
	return i, err
}

const createUser = `-- name: CreateUser :one
INSERT INTO "user" (username, first_name, last_name, phone_number, email, date_of_birth, experience, education, skills)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
RETURNING id, username, first_name, last_name, phone_number, email, date_of_birth, experience, education, skills
`

type CreateUserParams struct {
	Username    string
	FirstName   string
	LastName    string
	PhoneNumber string
	Email       string
	DateOfBirth pgtype.Date
	Experience  []string
	Education   string
	Skills      []string
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRow(ctx, createUser,
		arg.Username,
		arg.FirstName,
		arg.LastName,
		arg.PhoneNumber,
		arg.Email,
		arg.DateOfBirth,
		arg.Experience,
		arg.Education,
		arg.Skills,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.FirstName,
		&i.LastName,
		&i.PhoneNumber,
		&i.Email,
		&i.DateOfBirth,
		&i.Experience,
		&i.Education,
		&i.Skills,
	)
	return i, err
}

const deleteJobApplication = `-- name: DeleteJobApplication :exec
DELETE
FROM job_application
WHERE "user" = $1
  AND job_listing = $2
`

type DeleteJobApplicationParams struct {
	User       int32
	JobListing int32
}

func (q *Queries) DeleteJobApplication(ctx context.Context, arg DeleteJobApplicationParams) error {
	_, err := q.db.Exec(ctx, deleteJobApplication, arg.User, arg.JobListing)
	return err
}

const getJobApplication = `-- name: GetJobApplication :one
SELECT ja.id,
       ja."user",
       ja.job_listing,
       ja.cover_letter,
       ja.status,
       ja.sent_date,
       ja.relevant_skills
FROM job_application ja
WHERE ja."user" = $1
  AND ja.job_listing = $2
`

type GetJobApplicationParams struct {
	User       int32
	JobListing int32
}

func (q *Queries) GetJobApplication(ctx context.Context, arg GetJobApplicationParams) (JobApplication, error) {
	row := q.db.QueryRow(ctx, getJobApplication, arg.User, arg.JobListing)
	var i JobApplication
	err := row.Scan(
		&i.ID,
		&i.User,
		&i.JobListing,
		&i.CoverLetter,
		&i.Status,
		&i.SentDate,
		&i.RelevantSkills,
	)
	return i, err
}

const getJobListings = `-- name: GetJobListings :many
SELECT jl.id,
       jl.title,
       jl.description,
       jl.salary,
       c.name AS company,
       jl.date_posted,
       jl.start_date,
       jl.end_date,
       jl.location,
       jl.field,
       jl.working_hours,
       jl.employment_type,
       jl.schedule
FROM job_listing jl
         JOIN
     company c ON jl.company = c.id
`

type GetJobListingsRow struct {
	ID             int32
	Title          string
	Description    string
	Salary         pgtype.Numeric
	Company        string
	DatePosted     pgtype.Date
	StartDate      pgtype.Date
	EndDate        pgtype.Date
	Location       string
	Field          string
	WorkingHours   string
	EmploymentType string
	Schedule       string
}

func (q *Queries) GetJobListings(ctx context.Context) ([]GetJobListingsRow, error) {
	rows, err := q.db.Query(ctx, getJobListings)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetJobListingsRow
	for rows.Next() {
		var i GetJobListingsRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.Salary,
			&i.Company,
			&i.DatePosted,
			&i.StartDate,
			&i.EndDate,
			&i.Location,
			&i.Field,
			&i.WorkingHours,
			&i.EmploymentType,
			&i.Schedule,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUser = `-- name: GetUser :one
SELECT u.id,
       u.username,
       u.first_name,
       u.last_name,
       u.phone_number,
       u.email,
       u.date_of_birth,
       u.experience,
       u.education,
       u.skills
FROM "user" u
WHERE u.username = $1
`

func (q *Queries) GetUser(ctx context.Context, username string) (User, error) {
	row := q.db.QueryRow(ctx, getUser, username)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.FirstName,
		&i.LastName,
		&i.PhoneNumber,
		&i.Email,
		&i.DateOfBirth,
		&i.Experience,
		&i.Education,
		&i.Skills,
	)
	return i, err
}

const getUserFavoriteJobListings = `-- name: GetUserFavoriteJobListings :many
SELECT jl.id,
       jl.title,
       jl.description,
       jl.salary,
       c.name AS company,
       jl.date_posted,
       jl.start_date,
       jl.end_date,
       jl.location,
       jl.field,
       jl.working_hours,
       jl.employment_type
FROM user_favorite_job_listing ufl
         JOIN
     job_listing jl ON jl.id = ufl.job_listing
         JOIN
     company c ON jl.company = c.id
WHERE ufl."user" = $1
`

type GetUserFavoriteJobListingsRow struct {
	ID             int32
	Title          string
	Description    string
	Salary         pgtype.Numeric
	Company        string
	DatePosted     pgtype.Date
	StartDate      pgtype.Date
	EndDate        pgtype.Date
	Location       string
	Field          string
	WorkingHours   string
	EmploymentType string
}

func (q *Queries) GetUserFavoriteJobListings(ctx context.Context, user int32) ([]GetUserFavoriteJobListingsRow, error) {
	rows, err := q.db.Query(ctx, getUserFavoriteJobListings, user)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUserFavoriteJobListingsRow
	for rows.Next() {
		var i GetUserFavoriteJobListingsRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.Salary,
			&i.Company,
			&i.DatePosted,
			&i.StartDate,
			&i.EndDate,
			&i.Location,
			&i.Field,
			&i.WorkingHours,
			&i.EmploymentType,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserJobApplications = `-- name: GetUserJobApplications :many
SELECT ja.id,
       ja."user",
       ja.job_listing,
       ja.cover_letter,
       ja.status,
       ja.sent_date,
       ja.relevant_skills,
       jl.title AS job_title,
       c.name   AS company
FROM job_application ja
         JOIN
     job_listing jl ON ja.job_listing = jl.id
         JOIN
     company c ON jl.company = c.id
WHERE ja.user = $1
`

type GetUserJobApplicationsRow struct {
	ID             int32
	User           int32
	JobListing     int32
	CoverLetter    pgtype.Text
	Status         string
	SentDate       pgtype.Date
	RelevantSkills []string
	JobTitle       string
	Company        string
}

func (q *Queries) GetUserJobApplications(ctx context.Context, user int32) ([]GetUserJobApplicationsRow, error) {
	rows, err := q.db.Query(ctx, getUserJobApplications, user)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUserJobApplicationsRow
	for rows.Next() {
		var i GetUserJobApplicationsRow
		if err := rows.Scan(
			&i.ID,
			&i.User,
			&i.JobListing,
			&i.CoverLetter,
			&i.Status,
			&i.SentDate,
			&i.RelevantSkills,
			&i.JobTitle,
			&i.Company,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeUserFavoriteJobListing = `-- name: RemoveUserFavoriteJobListing :exec
DELETE
FROM user_favorite_job_listing
WHERE "user" = $1
  AND job_listing = $2
`

type RemoveUserFavoriteJobListingParams struct {
	User       int32
	JobListing int32
}

func (q *Queries) RemoveUserFavoriteJobListing(ctx context.Context, arg RemoveUserFavoriteJobListingParams) error {
	_, err := q.db.Exec(ctx, removeUserFavoriteJobListing, arg.User, arg.JobListing)
	return err
}

const updateJobApplication = `-- name: UpdateJobApplication :one
UPDATE job_application
SET cover_letter    = $3,
    status          = $4,
    sent_date       = $5,
    relevant_skills = $6
WHERE "user" = $1
  AND job_listing = $2
RETURNING id, "user", job_listing, cover_letter, status, sent_date, relevant_skills
`

type UpdateJobApplicationParams struct {
	User           int32
	JobListing     int32
	CoverLetter    pgtype.Text
	Status         string
	SentDate       pgtype.Date
	RelevantSkills []string
}

func (q *Queries) UpdateJobApplication(ctx context.Context, arg UpdateJobApplicationParams) (JobApplication, error) {
	row := q.db.QueryRow(ctx, updateJobApplication,
		arg.User,
		arg.JobListing,
		arg.CoverLetter,
		arg.Status,
		arg.SentDate,
		arg.RelevantSkills,
	)
	var i JobApplication
	err := row.Scan(
		&i.ID,
		&i.User,
		&i.JobListing,
		&i.CoverLetter,
		&i.Status,
		&i.SentDate,
		&i.RelevantSkills,
	)
	return i, err
}

const updateUser = `-- name: UpdateUser :one
UPDATE "user"
SET username      = $2,
    first_name    = $3,
    last_name     = $4,
    phone_number  = $5,
    email         = $6,
    date_of_birth = $7,
    experience    = $8,
    education     = $9,
    skills        = $10
WHERE id = $1
RETURNING id, username, first_name, last_name, phone_number, email, date_of_birth, experience, education, skills
`

type UpdateUserParams struct {
	ID          int32
	Username    string
	FirstName   string
	LastName    string
	PhoneNumber string
	Email       string
	DateOfBirth pgtype.Date
	Experience  []string
	Education   string
	Skills      []string
}

func (q *Queries) UpdateUser(ctx context.Context, arg UpdateUserParams) (User, error) {
	row := q.db.QueryRow(ctx, updateUser,
		arg.ID,
		arg.Username,
		arg.FirstName,
		arg.LastName,
		arg.PhoneNumber,
		arg.Email,
		arg.DateOfBirth,
		arg.Experience,
		arg.Education,
		arg.Skills,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.FirstName,
		&i.LastName,
		&i.PhoneNumber,
		&i.Email,
		&i.DateOfBirth,
		&i.Experience,
		&i.Education,
		&i.Skills,
	)
	return i, err
}
